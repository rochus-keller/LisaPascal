

// This file was automatically generated by Coco/R; don't modify it.
#include "LisaParser.h"
#include "PpLexer.h"


namespace Lisa {


static QString coco_string_create( const wchar_t* str )
{
    return QString::fromStdWString(str);
}

int Parser::peek( quint8 la )
{
	if( la == 0 )
		return d_cur.d_type;
	else if( la == 1 )
		return d_next.d_type;
	else
		return scanner->peekToken( la - 1 ).d_type;
}

void Parser::RunParser()
{
    d_stack.push(&d_root);
    Parse();
    d_stack.pop();
}
    
void Parser::SynErr(int n, const char* ctx) {
    if (errDist >= minErrDist)
       SynErr(d_next.d_lineNr, d_next.d_colNr, n, ctx, QString(), d_next.d_sourcePath);
	errDist = 0;
}

void Parser::SemErr(const char* msg) {
	if (errDist >= minErrDist)
		error(d_cur.d_lineNr, d_cur.d_colNr, msg, d_cur.d_sourcePath);
	errDist = 0;
}

void Parser::Get() {
	for (;;) {
		d_cur = d_next;
		d_next = scanner->nextToken();
        bool deliverToParser = false;
        switch( d_next.d_type )
        {
        case Lisa::Tok_Invalid:
        	if( !d_next.d_val.isEmpty() )
            	SynErr( d_next.d_type, d_next.d_val );
            // else errors already handeled in lexer
            break;
        case Lisa::Tok_Comment:
            d_comments.append(d_next);
            break;
        default:
            deliverToParser = true;
            break;
        }

        if( deliverToParser )
        {
            if( d_next.d_type == Lisa::Tok_Eof )
                d_next.d_type = _EOF;

            la->kind = d_next.d_type;
            if (la->kind <= maxT)
            {
                ++errDist;
                break;
            }
        }

		d_next = d_cur;
	}
}

void Parser::Expect(int n, const char* ctx ) {
	if (la->kind==n) Get(); else { SynErr(n, ctx); }
}

void Parser::ExpectWeak(int n, int follow) {
	if (la->kind == n) Get();
	else {
		SynErr(n);
		while (!StartOf(follow)) Get();
	}
}

bool Parser::WeakSeparator(int n, int syFol, int repFol) {
	if (la->kind == n) {Get(); return true;}
	else if (StartOf(repFol)) {return false;}
	else {
		SynErr(n);
		while (!(StartOf(syFol) || StartOf(repFol) || StartOf(0))) {
			Get();
		}
		return StartOf(syFol);
	}
}

void Parser::LisaPascal() {
		d_stack.push(&d_root); 
		if (la->kind == _T_program) {
			program_();
		} else if (la->kind == _T_unit) {
			regular_unit();
		} else if (StartOf(1)) {
			non_regular_unit();
		} else SynErr(88,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::program_() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_program_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		program_heading();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_uses) {
			uses_clause();
		}
		block();
		if (la->kind == _T_begin) {
			statement_part();
			Expect(_T_Dot,__FUNCTION__);
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::regular_unit() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_regular_unit, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		unit_heading();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		interface_part();
		implementation_part();
		if (la->kind == _T_end) {
			Get();
			addTerminal(); 
			Expect(_T_Dot,__FUNCTION__);
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::non_regular_unit() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_non_regular_unit, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		while (( peek(1) == _T_procedure || peek(1) == _T_function ) ) {
			procedure_and_function_declaration_part();
		}
		if (la->kind == _T_begin || la->kind == _T_end) {
			if (la->kind == _T_begin) {
				statement_part();
				Expect(_T_Dot,__FUNCTION__);
				addTerminal(); 
			} else {
				Get();
				addTerminal(); 
				Expect(_T_Dot,__FUNCTION__);
				addTerminal(); 
			}
		}
		d_stack.pop(); 
}

void Parser::program_heading() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_program_heading, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_program,__FUNCTION__);
		addTerminal(); 
		Expect(_T_identifier,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Lpar) {
			Get();
			addTerminal(); 
			program_parameters();
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::uses_clause() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_uses_clause, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_uses,__FUNCTION__);
		addTerminal(); 
		identifier_list();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::block() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_block, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_label) {
			label_declaration_part();
		}
		if (la->kind == _T_const) {
			constant_declaration_part();
		}
		if (la->kind == _T_type) {
			type_declaration_part();
		}
		if (la->kind == _T_var) {
			variable_declaration_part();
		}
		if (la->kind == _T_function || la->kind == _T_procedure) {
			procedure_and_function_declaration_part();
		}
		d_stack.pop(); 
}

void Parser::statement_part() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_statement_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		compound_statement();
		d_stack.pop(); 
}

void Parser::program_parameters() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_program_parameters, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		identifier_list();
		d_stack.pop(); 
}

void Parser::identifier_list() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_identifier_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_identifier,__FUNCTION__);
		addTerminal(); 
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			Expect(_T_identifier,__FUNCTION__);
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::unit_heading() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_unit_heading, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_unit,__FUNCTION__);
		addTerminal(); 
		Expect(_T_identifier,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::interface_part() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_interface_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_interface,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_uses) {
			uses_clause();
		}
		if (la->kind == _T_const) {
			constant_declaration_part();
		}
		if (la->kind == _T_type) {
			type_declaration_part();
		}
		if (la->kind == _T_var) {
			variable_declaration_part();
		}
		if (la->kind == _T_function || la->kind == _T_procedure) {
			procedure_and_function_interface_part();
		}
		d_stack.pop(); 
}

void Parser::implementation_part() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_implementation_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_implementation,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_const) {
			constant_declaration_part();
		}
		if (la->kind == _T_type) {
			type_declaration_part();
		}
		if (la->kind == _T_var) {
			variable_declaration_part();
		}
		if (la->kind == _T_function || la->kind == _T_procedure) {
			procedure_and_function_declaration_part();
		}
		d_stack.pop(); 
}

void Parser::constant_declaration_part() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_constant_declaration_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_const,__FUNCTION__);
		addTerminal(); 
		constant_declaration();
		while (la->kind == _T_identifier) {
			constant_declaration();
		}
		d_stack.pop(); 
}

void Parser::type_declaration_part() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_type_declaration_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_type,__FUNCTION__);
		addTerminal(); 
		type_declaration();
		while (la->kind == _T_identifier) {
			type_declaration();
		}
		d_stack.pop(); 
}

void Parser::variable_declaration_part() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_variable_declaration_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_var,__FUNCTION__);
		addTerminal(); 
		variable_declaration();
		while (la->kind == _T_identifier) {
			variable_declaration();
		}
		d_stack.pop(); 
}

void Parser::procedure_and_function_interface_part() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_procedure_and_function_interface_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		while (la->kind == _T_function || la->kind == _T_procedure) {
			if (la->kind == _T_procedure) {
				procedure_heading();
				Expect(_T_Semi,__FUNCTION__);
				addTerminal(); 
			} else {
				function_heading();
				Expect(_T_Semi,__FUNCTION__);
				addTerminal(); 
			}
		}
		d_stack.pop(); 
}

void Parser::procedure_and_function_declaration_part() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_procedure_and_function_declaration_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		while (la->kind == _T_function || la->kind == _T_procedure) {
			if (la->kind == _T_procedure) {
				procedure_declaration();
			} else {
				function_declaration();
			}
		}
		d_stack.pop(); 
}

void Parser::label_declaration_part() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_label_declaration_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_label,__FUNCTION__);
		addTerminal(); 
		label_();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			label_();
		}
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::label_() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_label_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_digit_sequence,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::constant_declaration() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_constant_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_identifier,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Eq,__FUNCTION__);
		addTerminal(); 
		constant();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::constant() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_constant, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(2)) {
			if (la->kind == _T_Plus || la->kind == _T_Minus) {
				sign();
			}
			if (la->kind == _T_identifier) {
				constant_identifier();
			} else if (la->kind == _T_unsigned_real || la->kind == _T_digit_sequence || la->kind == _T_hex_digit_sequence) {
				unsigned_number();
			} else SynErr(89,__FUNCTION__);
		} else if (la->kind == _T_string_literal) {
			Get();
			addTerminal(); 
		} else SynErr(90,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::sign() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_sign, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Plus) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Minus) {
			Get();
			addTerminal(); 
		} else SynErr(91,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::constant_identifier() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_constant_identifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_identifier,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::unsigned_number() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_unsigned_number, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_digit_sequence || la->kind == _T_hex_digit_sequence) {
			unsigned_integer();
		} else if (la->kind == _T_unsigned_real) {
			Get();
			addTerminal(); 
		} else SynErr(92,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::type_declaration() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_type_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_identifier,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Eq,__FUNCTION__);
		addTerminal(); 
		type_();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::type_() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_type_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(3)) {
			simple_type();
		} else if (la->kind == _T_string) {
			string_type();
		} else if (StartOf(4)) {
			structured_type();
		} else if (la->kind == _T_Hat) {
			pointer_type();
		} else SynErr(93,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::variable_declaration() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_variable_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		identifier_list();
		Expect(_T_Colon,__FUNCTION__);
		addTerminal(); 
		type_();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::procedure_heading() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_procedure_heading, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_procedure,__FUNCTION__);
		addTerminal(); 
		Expect(_T_identifier,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Lpar) {
			formal_parameter_list();
		}
		d_stack.pop(); 
}

void Parser::function_heading() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_function_heading, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_function,__FUNCTION__);
		addTerminal(); 
		Expect(_T_identifier,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Lpar) {
			formal_parameter_list();
		}
		if (la->kind == _T_Colon) {
			Get();
			addTerminal(); 
			result_type();
		}
		d_stack.pop(); 
}

void Parser::procedure_declaration() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_procedure_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		procedure_heading();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		body_();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::function_declaration() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_function_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		function_heading();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		body_();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::body_() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_body_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(5)) {
			block();
			statement_part();
		} else if (la->kind == _T_forward) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_external) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_inline) {
			Get();
			addTerminal(); 
			constant();
		} else SynErr(94,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::compound_statement() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_compound_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_begin,__FUNCTION__);
		addTerminal(); 
		statement_sequence();
		Expect(_T_end,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::formal_parameter_list() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_formal_parameter_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		formal_parameter_section();
		while (la->kind == _T_Semi) {
			Get();
			addTerminal(); 
			formal_parameter_section();
		}
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::result_type() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_result_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		type_identifier();
		d_stack.pop(); 
}

void Parser::type_identifier() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_type_identifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_identifier,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::formal_parameter_section() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_formal_parameter_section, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_var || la->kind == _T_identifier) {
			parameter_declaration();
		} else if (la->kind == _T_procedure) {
			procedure_heading();
		} else if (la->kind == _T_function) {
			function_heading();
		} else SynErr(95,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::parameter_declaration() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_parameter_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_var) {
			Get();
			addTerminal(); 
		}
		identifier_list();
		Expect(_T_Colon,__FUNCTION__);
		addTerminal(); 
		type_identifier();
		d_stack.pop(); 
}

void Parser::statement_sequence() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_statement_sequence, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		statement();
		while (la->kind == _T_Semi) {
			Get();
			addTerminal(); 
			statement();
		}
		d_stack.pop(); 
}

void Parser::statement() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_digit_sequence) {
			label_();
			Expect(_T_Colon,__FUNCTION__);
			addTerminal(); 
		}
		if (StartOf(6)) {
			if (la->kind == _T_goto || la->kind == _T_identifier) {
				simple_statement();
			}
		} else if (StartOf(7)) {
			structured_statement();
		} else SynErr(96,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::simple_statement() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_simple_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_identifier) {
			assigOrCall();
		} else if (la->kind == _T_goto) {
			goto_statement();
		} else SynErr(97,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::structured_statement() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_structured_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_begin) {
			compound_statement();
		} else if (la->kind == _T_for || la->kind == _T_repeat || la->kind == _T_while) {
			repetitive_statement();
		} else if (la->kind == _T_case || la->kind == _T_if) {
			conditional_statement();
		} else if (la->kind == _T_with) {
			with_statement();
		} else SynErr(98,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::assigOrCall() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_assigOrCall, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		variable_reference();
		if (la->kind == _T_ColonEq) {
			Get();
			addTerminal(); 
			expression();
		} else if (StartOf(8)) {
			if (la->kind == _T_Lpar) {
				actual_parameter_list();
			}
		} else SynErr(99,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::goto_statement() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_goto_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_goto,__FUNCTION__);
		addTerminal(); 
		label_();
		d_stack.pop(); 
}

void Parser::variable_reference() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_variable_reference, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		variable_identifier();
		while (la->kind == _T_Dot || la->kind == _T_Lbrack || la->kind == _T_Hat) {
			qualifier();
		}
		d_stack.pop(); 
}

void Parser::expression() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		simple_expression();
		if (StartOf(9)) {
			relational_operator();
			simple_expression();
		}
		d_stack.pop(); 
}

void Parser::actual_parameter_list() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_actual_parameter_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		actual_parameter();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			actual_parameter();
		}
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::repetitive_statement() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_repetitive_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_while) {
			while_statement();
		} else if (la->kind == _T_repeat) {
			repeat_statement();
		} else if (la->kind == _T_for) {
			for_statement();
		} else SynErr(100,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::conditional_statement() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_conditional_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_if) {
			if_statement();
		} else if (la->kind == _T_case) {
			case_statement();
		} else SynErr(101,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::with_statement() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_with_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_with,__FUNCTION__);
		addTerminal(); 
		variable_reference();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			variable_reference();
		}
		Expect(_T_do,__FUNCTION__);
		addTerminal(); 
		statement();
		d_stack.pop(); 
}

void Parser::while_statement() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_while_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_while,__FUNCTION__);
		addTerminal(); 
		expression();
		Expect(_T_do,__FUNCTION__);
		addTerminal(); 
		statement();
		d_stack.pop(); 
}

void Parser::repeat_statement() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_repeat_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_repeat,__FUNCTION__);
		addTerminal(); 
		statement_sequence();
		Expect(_T_until,__FUNCTION__);
		addTerminal(); 
		expression();
		d_stack.pop(); 
}

void Parser::for_statement() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_for_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_for,__FUNCTION__);
		addTerminal(); 
		variable_identifier();
		Expect(_T_ColonEq,__FUNCTION__);
		addTerminal(); 
		initial_value();
		if (la->kind == _T_to) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_downto) {
			Get();
			addTerminal(); 
		} else SynErr(102,__FUNCTION__);
		final_value();
		Expect(_T_do,__FUNCTION__);
		addTerminal(); 
		statement();
		d_stack.pop(); 
}

void Parser::variable_identifier() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_variable_identifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_identifier,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::initial_value() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_initial_value, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		expression();
		d_stack.pop(); 
}

void Parser::final_value() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_final_value, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		expression();
		d_stack.pop(); 
}

void Parser::if_statement() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_if_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_if,__FUNCTION__);
		addTerminal(); 
		expression();
		Expect(_T_then,__FUNCTION__);
		addTerminal(); 
		statement();
		if (la->kind == _T_else) {
			Get();
			addTerminal(); 
			statement();
		}
		d_stack.pop(); 
}

void Parser::case_statement() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_case_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_case,__FUNCTION__);
		addTerminal(); 
		expression();
		Expect(_T_of,__FUNCTION__);
		addTerminal(); 
		case_limb();
		while (peek(1) == _T_Semi && !( peek(2) == _T_end ) && !( peek(2) == _T_otherwise ) ) {
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
			if (StartOf(10)) {
				case_limb();
			}
		}
		if (peek(1) == _T_Semi && peek(2) == _T_otherwise ) {
			otherwise_clause();
		}
		if (la->kind == _T_Semi) {
			Get();
			addTerminal(); 
		}
		Expect(_T_end,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::case_limb() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_case_limb, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		case_label_list();
		Expect(_T_Colon,__FUNCTION__);
		addTerminal(); 
		statement();
		d_stack.pop(); 
}

void Parser::otherwise_clause() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_otherwise_clause, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		Expect(_T_otherwise,__FUNCTION__);
		addTerminal(); 
		statement();
		d_stack.pop(); 
}

void Parser::case_label_list() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_case_label_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		constant();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			constant();
		}
		d_stack.pop(); 
}

void Parser::actual_parameter() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_actual_parameter, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		expression();
		d_stack.pop(); 
}

void Parser::simple_expression() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_simple_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Plus || la->kind == _T_Minus) {
			sign();
		}
		term();
		while (la->kind == _T_Plus || la->kind == _T_Minus || la->kind == _T_or) {
			addition_operator();
			term();
		}
		d_stack.pop(); 
}

void Parser::relational_operator() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_relational_operator, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_Eq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_LtGt: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Lt: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Leq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Gt: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Geq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_in: {
			Get();
			addTerminal(); 
			break;
		}
		default: SynErr(103,__FUNCTION__); break;
		}
		d_stack.pop(); 
}

void Parser::term() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_term, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		factor();
		while (StartOf(11)) {
			multiplication_operator();
			factor();
		}
		d_stack.pop(); 
}

void Parser::addition_operator() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_addition_operator, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Plus) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Minus) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_or) {
			Get();
			addTerminal(); 
		} else SynErr(104,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::factor() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_factor, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_At: {
			Get();
			addTerminal(); 
			variable_reference();
			break;
		}
		case _T_identifier: {
			Get();
			addTerminal(); 
			if (la->kind == _T_Lpar) {
				actual_parameter_list();
			} else if (StartOf(12)) {
				while (la->kind == _T_Dot || la->kind == _T_Lbrack || la->kind == _T_Hat) {
					qualifier();
				}
			} else SynErr(105,__FUNCTION__);
			break;
		}
		case _T_unsigned_real: case _T_digit_sequence: case _T_hex_digit_sequence: {
			unsigned_number();
			break;
		}
		case _T_string_literal: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_nil: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Lbrack: {
			set_literal();
			break;
		}
		case _T_Lpar: {
			Get();
			addTerminal(); 
			expression();
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _T_not: {
			Get();
			addTerminal(); 
			factor();
			break;
		}
		default: SynErr(106,__FUNCTION__); break;
		}
		d_stack.pop(); 
}

void Parser::multiplication_operator() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_multiplication_operator, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_Star: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Slash: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Colon: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_div: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_mod: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_and: {
			Get();
			addTerminal(); 
			break;
		}
		default: SynErr(107,__FUNCTION__); break;
		}
		d_stack.pop(); 
}

void Parser::qualifier() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_qualifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Lbrack) {
			index();
		} else if (la->kind == _T_Dot) {
			field_designator();
		} else if (la->kind == _T_Hat) {
			dereferencer();
		} else SynErr(108,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::set_literal() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_set_literal, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lbrack,__FUNCTION__);
		addTerminal(); 
		if (StartOf(13)) {
			member_group();
			while (la->kind == _T_Comma) {
				Get();
				addTerminal(); 
				member_group();
			}
		}
		Expect(_T_Rbrack,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::index() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_index, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lbrack,__FUNCTION__);
		addTerminal(); 
		expression_list();
		Expect(_T_Rbrack,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::field_designator() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_field_designator, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Dot,__FUNCTION__);
		addTerminal(); 
		field_identifier();
		d_stack.pop(); 
}

void Parser::dereferencer() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_dereferencer, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Hat,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::expression_list() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_expression_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		expression();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			expression();
		}
		d_stack.pop(); 
}

void Parser::field_identifier() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_field_identifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_identifier,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::member_group() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_member_group, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		expression();
		if (la->kind == _T_2Dot) {
			Get();
			addTerminal(); 
			expression();
		}
		d_stack.pop(); 
}

void Parser::simple_type() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_simple_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (peek(1) == _T_identifier && !( peek(2) == _T_2Dot ) ) {
			Expect(_T_identifier,__FUNCTION__);
			addTerminal(); 
		} else if (StartOf(10)) {
			subrange_type();
		} else if (la->kind == _T_Lpar) {
			enumerated_type();
		} else SynErr(109,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::string_type() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_string_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_string,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Lbrack,__FUNCTION__);
		addTerminal(); 
		size_attribute();
		Expect(_T_Rbrack,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::structured_type() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_structured_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_packed) {
			Get();
			addTerminal(); 
		}
		if (la->kind == _T_array) {
			array_type();
		} else if (la->kind == _T_record) {
			record_type();
		} else if (la->kind == _T_set) {
			set_type();
		} else if (la->kind == _T_file) {
			file_type();
		} else SynErr(110,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::pointer_type() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_pointer_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Hat,__FUNCTION__);
		addTerminal(); 
		type_identifier();
		d_stack.pop(); 
}

void Parser::subrange_type() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_subrange_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		constant();
		if (la->kind == _T_2Dot) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Colon) {
			Get();
			addTerminal(); 
		} else SynErr(111,__FUNCTION__);
		constant();
		d_stack.pop(); 
}

void Parser::enumerated_type() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_enumerated_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		identifier_list();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::ordinal_type() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_ordinal_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		simple_type();
		d_stack.pop(); 
}

void Parser::size_attribute() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_size_attribute, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_digit_sequence || la->kind == _T_hex_digit_sequence) {
			unsigned_integer();
		} else if (la->kind == _T_identifier) {
			Get();
			addTerminal(); 
		} else SynErr(112,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::unsigned_integer() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_unsigned_integer, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_digit_sequence) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_hex_digit_sequence) {
			Get();
			addTerminal(); 
		} else SynErr(113,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::array_type() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_array_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_array,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Lbrack,__FUNCTION__);
		addTerminal(); 
		index_type();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			index_type();
		}
		Expect(_T_Rbrack,__FUNCTION__);
		addTerminal(); 
		Expect(_T_of,__FUNCTION__);
		addTerminal(); 
		type_();
		d_stack.pop(); 
}

void Parser::record_type() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_record_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_record,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_case || la->kind == _T_identifier) {
			field_list();
		}
		Expect(_T_end,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::set_type() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_set_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_set,__FUNCTION__);
		addTerminal(); 
		Expect(_T_of,__FUNCTION__);
		addTerminal(); 
		ordinal_type();
		d_stack.pop(); 
}

void Parser::file_type() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_file_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_file,__FUNCTION__);
		addTerminal(); 
		Expect(_T_of,__FUNCTION__);
		addTerminal(); 
		type_();
		d_stack.pop(); 
}

void Parser::index_type() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_index_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		ordinal_type();
		d_stack.pop(); 
}

void Parser::field_list() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_field_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_identifier) {
			fixed_part();
			if (peek(1) == _T_Semi && peek(2) == _T_case ) {
				Expect(_T_Semi,__FUNCTION__);
				addTerminal(); 
				variant_part();
			}
		} else if (la->kind == _T_case) {
			variant_part();
		} else SynErr(114,__FUNCTION__);
		if (la->kind == _T_Semi) {
			Get();
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::fixed_part() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_fixed_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		field_declaration();
		while (peek(1) == _T_Semi && peek(2) == _T_identifier ) {
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
			field_declaration();
		}
		d_stack.pop(); 
}

void Parser::variant_part() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_variant_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_case,__FUNCTION__);
		addTerminal(); 
		if (peek(1) == _T_identifier && peek(2) == _T_Colon ) {
			tag_field();
		}
		type_identifier();
		Expect(_T_of,__FUNCTION__);
		addTerminal(); 
		variant();
		while (peek(1) == _T_Semi && !( peek(2) == _T_end ) ) {
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
			variant();
		}
		d_stack.pop(); 
}

void Parser::field_declaration() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_field_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		identifier_list();
		Expect(_T_Colon,__FUNCTION__);
		addTerminal(); 
		type_();
		d_stack.pop(); 
}

void Parser::tag_field() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_tag_field, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_identifier,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Colon,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::variant() {
		Lisa::SynTree* n = new Lisa::SynTree( Lisa::SynTree::R_variant, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		case_label_list();
		Expect(_T_Colon,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_case || la->kind == _T_identifier) {
			field_list();
		}
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}




// If the user declared a method Init and a mehtod Destroy they should
// be called in the contructur and the destructor respctively.
//
// The following templates are used to recognize if the user declared
// the methods Init and Destroy.

template<typename T>
struct ParserInitExistsRecognizer {
	template<typename U, void (U::*)() = &U::Init>
	struct ExistsIfInitIsDefinedMarker{};

	struct InitIsMissingType {
		char dummy1;
	};
	
	struct InitExistsType {
		char dummy1; char dummy2;
	};

	// exists always
	template<typename U>
	static InitIsMissingType is_here(...);

	// exist only if ExistsIfInitIsDefinedMarker is defined
	template<typename U>
	static InitExistsType is_here(ExistsIfInitIsDefinedMarker<U>*);

	enum { InitExists = (sizeof(is_here<T>(NULL)) == sizeof(InitExistsType)) };
};

template<typename T>
struct ParserDestroyExistsRecognizer {
	template<typename U, void (U::*)() = &U::Destroy>
	struct ExistsIfDestroyIsDefinedMarker{};

	struct DestroyIsMissingType {
		char dummy1;
	};
	
	struct DestroyExistsType {
		char dummy1; char dummy2;
	};

	// exists always
	template<typename U>
	static DestroyIsMissingType is_here(...);

	// exist only if ExistsIfDestroyIsDefinedMarker is defined
	template<typename U>
	static DestroyExistsType is_here(ExistsIfDestroyIsDefinedMarker<U>*);

	enum { DestroyExists = (sizeof(is_here<T>(NULL)) == sizeof(DestroyExistsType)) };
};

// The folloing templates are used to call the Init and Destroy methods if they exist.

// Generic case of the ParserInitCaller, gets used if the Init method is missing
template<typename T, bool = ParserInitExistsRecognizer<T>::InitExists>
struct ParserInitCaller {
	static void CallInit(T *t) {
		// nothing to do
	}
};

// True case of the ParserInitCaller, gets used if the Init method exists
template<typename T>
struct ParserInitCaller<T, true> {
	static void CallInit(T *t) {
		t->Init();
	}
};

// Generic case of the ParserDestroyCaller, gets used if the Destroy method is missing
template<typename T, bool = ParserDestroyExistsRecognizer<T>::DestroyExists>
struct ParserDestroyCaller {
	static void CallDestroy(T *t) {
		// nothing to do
	}
};

// True case of the ParserDestroyCaller, gets used if the Destroy method exists
template<typename T>
struct ParserDestroyCaller<T, true> {
	static void CallDestroy(T *t) {
		t->Destroy();
	}
};

void Parser::Parse() {
	d_cur = Token();
	d_next = Token();
	Get();
	LisaPascal();
	Expect(0,__FUNCTION__);
}

Parser::Parser(PpLexer *scanner) {
	maxT = 87;

	ParserInitCaller<Parser>::CallInit(this);
	la = &d_dummy;
	minErrDist = 2;
	errDist = minErrDist;
	this->scanner = scanner;
}

bool Parser::StartOf(int s) {
	const bool T = true;
	const bool x = false;

	static bool set[14][89] = {
		{T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,T, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, T,T,x,x, x,x,x,x, x},
		{x,x,T,x, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, T,T,T,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,T,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,T,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,T,T, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, T,T,T,x, x,x,x,x, x},
		{x,x,x,x, x,T,x,x, x,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, T,T,x,T, T,T,T,T, T,T,x,T, T,T,T,T, T,T,x,T, T,T,x,x, x,T,x,x, x,x,x,T, T,T,T,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,T,x, x,T,T,x, x,x,x,x, x,x,x,x, T,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,T,x, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, T,T,T,x, x,x,x,x, x}
	};



	return set[s][la->kind];
}

Parser::~Parser() {
	ParserDestroyCaller<Parser>::CallDestroy(this);
}

void Parser::SynErr(int line, int col, int n, const char* ctx, const QString& str, const QString& path ) {
	QString s;
	QString ctxStr;
	if( ctx )
		ctxStr = QString( " in %1" ).arg(ctx);
    if( n == 0 )
        s = QString("EOF expected%1").arg(ctxStr);
    else if( n < TT_Specials )
        s = QString("'%2' expected%1").arg(ctxStr).arg(tokenTypeString(n));
    else if( n <= TT_Max )
        s = QString("%2 expected%1").arg(ctxStr).arg(tokenTypeString(n));
    else
	switch (n) {
			case 0: s = coco_string_create(L"EOF expected"); break;
			case 1: s = coco_string_create(L"T_Literals_ expected"); break;
			case 2: s = coco_string_create(L"T_Lpar expected"); break;
			case 3: s = coco_string_create(L"T_Latt expected"); break;
			case 4: s = coco_string_create(L"T_Rpar expected"); break;
			case 5: s = coco_string_create(L"T_Star expected"); break;
			case 6: s = coco_string_create(L"T_Ratt expected"); break;
			case 7: s = coco_string_create(L"T_Plus expected"); break;
			case 8: s = coco_string_create(L"T_Comma expected"); break;
			case 9: s = coco_string_create(L"T_Minus expected"); break;
			case 10: s = coco_string_create(L"T_Dot expected"); break;
			case 11: s = coco_string_create(L"T_2Dot expected"); break;
			case 12: s = coco_string_create(L"T_Slash expected"); break;
			case 13: s = coco_string_create(L"T_Colon expected"); break;
			case 14: s = coco_string_create(L"T_ColonEq expected"); break;
			case 15: s = coco_string_create(L"T_Semi expected"); break;
			case 16: s = coco_string_create(L"T_Lt expected"); break;
			case 17: s = coco_string_create(L"T_Leq expected"); break;
			case 18: s = coco_string_create(L"T_LtGt expected"); break;
			case 19: s = coco_string_create(L"T_Eq expected"); break;
			case 20: s = coco_string_create(L"T_Gt expected"); break;
			case 21: s = coco_string_create(L"T_Geq expected"); break;
			case 22: s = coco_string_create(L"T_At expected"); break;
			case 23: s = coco_string_create(L"T_Lbrack expected"); break;
			case 24: s = coco_string_create(L"T_Rbrack expected"); break;
			case 25: s = coco_string_create(L"T_Hat expected"); break;
			case 26: s = coco_string_create(L"T_Lbrace expected"); break;
			case 27: s = coco_string_create(L"T_Rbrace expected"); break;
			case 28: s = coco_string_create(L"T_Keywords_ expected"); break;
			case 29: s = coco_string_create(L"T_and expected"); break;
			case 30: s = coco_string_create(L"T_array expected"); break;
			case 31: s = coco_string_create(L"T_begin expected"); break;
			case 32: s = coco_string_create(L"T_case expected"); break;
			case 33: s = coco_string_create(L"T_const expected"); break;
			case 34: s = coco_string_create(L"T_creation expected"); break;
			case 35: s = coco_string_create(L"T_div expected"); break;
			case 36: s = coco_string_create(L"T_do expected"); break;
			case 37: s = coco_string_create(L"T_downto expected"); break;
			case 38: s = coco_string_create(L"T_else expected"); break;
			case 39: s = coco_string_create(L"T_end expected"); break;
			case 40: s = coco_string_create(L"T_external expected"); break;
			case 41: s = coco_string_create(L"T_file expected"); break;
			case 42: s = coco_string_create(L"T_for expected"); break;
			case 43: s = coco_string_create(L"T_forward expected"); break;
			case 44: s = coco_string_create(L"T_function expected"); break;
			case 45: s = coco_string_create(L"T_goto expected"); break;
			case 46: s = coco_string_create(L"T_if expected"); break;
			case 47: s = coco_string_create(L"T_implementation expected"); break;
			case 48: s = coco_string_create(L"T_in expected"); break;
			case 49: s = coco_string_create(L"T_inline expected"); break;
			case 50: s = coco_string_create(L"T_interface expected"); break;
			case 51: s = coco_string_create(L"T_intrinsic expected"); break;
			case 52: s = coco_string_create(L"T_label expected"); break;
			case 53: s = coco_string_create(L"T_methods expected"); break;
			case 54: s = coco_string_create(L"T_mod expected"); break;
			case 55: s = coco_string_create(L"T_nil expected"); break;
			case 56: s = coco_string_create(L"T_not expected"); break;
			case 57: s = coco_string_create(L"T_of expected"); break;
			case 58: s = coco_string_create(L"T_or expected"); break;
			case 59: s = coco_string_create(L"T_otherwise expected"); break;
			case 60: s = coco_string_create(L"T_packed expected"); break;
			case 61: s = coco_string_create(L"T_procedure expected"); break;
			case 62: s = coco_string_create(L"T_program expected"); break;
			case 63: s = coco_string_create(L"T_record expected"); break;
			case 64: s = coco_string_create(L"T_repeat expected"); break;
			case 65: s = coco_string_create(L"T_set expected"); break;
			case 66: s = coco_string_create(L"T_string expected"); break;
			case 67: s = coco_string_create(L"T_subclass expected"); break;
			case 68: s = coco_string_create(L"T_then expected"); break;
			case 69: s = coco_string_create(L"T_to expected"); break;
			case 70: s = coco_string_create(L"T_type expected"); break;
			case 71: s = coco_string_create(L"T_unit expected"); break;
			case 72: s = coco_string_create(L"T_until expected"); break;
			case 73: s = coco_string_create(L"T_uses expected"); break;
			case 74: s = coco_string_create(L"T_var expected"); break;
			case 75: s = coco_string_create(L"T_while expected"); break;
			case 76: s = coco_string_create(L"T_with expected"); break;
			case 77: s = coco_string_create(L"T_Specials_ expected"); break;
			case 78: s = coco_string_create(L"T_identifier expected"); break;
			case 79: s = coco_string_create(L"T_unsigned_real expected"); break;
			case 80: s = coco_string_create(L"T_digit_sequence expected"); break;
			case 81: s = coco_string_create(L"T_hex_digit_sequence expected"); break;
			case 82: s = coco_string_create(L"T_string_literal expected"); break;
			case 83: s = coco_string_create(L"T_Comment expected"); break;
			case 84: s = coco_string_create(L"T_Directive expected"); break;
			case 85: s = coco_string_create(L"T_Eof expected"); break;
			case 86: s = coco_string_create(L"T_MaxToken_ expected"); break;
			case 87: s = coco_string_create(L"??? expected"); break;
			case 88: s = coco_string_create(L"invalid LisaPascal"); break;
			case 89: s = coco_string_create(L"invalid constant"); break;
			case 90: s = coco_string_create(L"invalid constant"); break;
			case 91: s = coco_string_create(L"invalid sign"); break;
			case 92: s = coco_string_create(L"invalid unsigned_number"); break;
			case 93: s = coco_string_create(L"invalid type_"); break;
			case 94: s = coco_string_create(L"invalid body_"); break;
			case 95: s = coco_string_create(L"invalid formal_parameter_section"); break;
			case 96: s = coco_string_create(L"invalid statement"); break;
			case 97: s = coco_string_create(L"invalid simple_statement"); break;
			case 98: s = coco_string_create(L"invalid structured_statement"); break;
			case 99: s = coco_string_create(L"invalid assigOrCall"); break;
			case 100: s = coco_string_create(L"invalid repetitive_statement"); break;
			case 101: s = coco_string_create(L"invalid conditional_statement"); break;
			case 102: s = coco_string_create(L"invalid for_statement"); break;
			case 103: s = coco_string_create(L"invalid relational_operator"); break;
			case 104: s = coco_string_create(L"invalid addition_operator"); break;
			case 105: s = coco_string_create(L"invalid factor"); break;
			case 106: s = coco_string_create(L"invalid factor"); break;
			case 107: s = coco_string_create(L"invalid multiplication_operator"); break;
			case 108: s = coco_string_create(L"invalid qualifier"); break;
			case 109: s = coco_string_create(L"invalid simple_type"); break;
			case 110: s = coco_string_create(L"invalid structured_type"); break;
			case 111: s = coco_string_create(L"invalid subrange_type"); break;
			case 112: s = coco_string_create(L"invalid size_attribute"); break;
			case 113: s = coco_string_create(L"invalid unsigned_integer"); break;
			case 114: s = coco_string_create(L"invalid field_list"); break;

		default:
		{
			s = QString( "generic error %1").arg(n);
		}
		break;
	}
    if( !str.isEmpty() )
        s = QString("%1 %2").arg(s).arg(str);
	error(line, col, s, path);
	//count++;
}

} // namespace

